<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rectangle Math Game - Colorful</title>
    <style>
        #game-container {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: none;
        }
        #feedback {
            font-size: 24px;
            margin-top: 10px;
        }
        #answerInput {
            font-size: 24px;
            margin-top: 10px;
            transition: transform 0.1s;
        }
        .shake {
            animation: shake 0.5s;
        }
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="700" height="300"></canvas>
        <div id="feedback"></div>
        <input type="text" id="answerInput" placeholder="Type your answer">
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const answerInput = document.getElementById('answerInput');
        const feedbackDiv = document.getElementById('feedback');

        class RectangleMathGame {
            constructor() {
                this.numbers = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9];
                this.shuffleArray(this.numbers);
                // this.operators = ['+', '-', '*', '/'];
                this.operators = ['*'];
                this.currentOp = this.operators[Math.floor(Math.random() * this.operators.length)];
                this.grid = this.createGrid();
                this.currentPair = this.getRandomPair();
                this.correctAnswer = this.calculateAnswer();
                this.userAnswer = '';
                this.feedback = '';
                this.feedbackTimer = 0;
                this.wrongFlashTimer = 0;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            createGrid() {
                const grid = [];
                const colors = [
                    '#FFD1DC', '#B5EAD7', '#C7CEEA', '#FFF9B1', '#E2C1F5', // Pastels: pink, green, blue, yellow, lavender
                    '#FFD1DC', '#B5EAD7', '#C7CEEA', '#FFF9B1', '#E2C1F5',
                    '#FFD1DC', '#B5EAD7', '#C7CEEA', '#FFF9B1', '#E2C1F5',
                    '#FFD1DC', '#B5EAD7', '#C7CEEA', '#FFF9B1', '#E2C1F5', '#FFFFFF' // White for operator
                ];
                this.shuffleArray(colors);
                let numIndex = 0;
                let colorIndex = 0;

                for (let y = 0; y < 3; y++) {
                    const row = [];
                    for (let x = 0; x < 7; x++) {
                        if (x === 3 && y === 1) { // Center operator
                            row.push({ type: 'operator', value: this.currentOp, color: colors[20] }); // White
                        } else {
                            row.push({ type: 'number', value: this.numbers[numIndex++], color: colors[colorIndex++] });
                        }
                    }
                    grid.push(row);
                }
                return grid;
            }

            getRandomPair() {
                const positions = [];
                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 7; x++) {
                        if (!(x === 3 && y === 1)) positions.push([x, y]);
                    }
                }
                const idx1 = Math.floor(Math.random() * positions.length);
                let idx2 = Math.floor(Math.random() * positions.length);
                while (idx2 === idx1) idx2 = Math.floor(Math.random() * positions.length);
                return [positions[idx1], positions[idx2]];
            }

            calculateAnswer() {
                const [pos1, pos2] = this.currentPair;
                const n1 = this.grid[pos1[1]][pos1[0]].value;
                const n2 = this.grid[pos2[1]][pos2[0]].value;
                switch (this.currentOp) {
                    case '+': return n1 + n2;
                    case '-': return n1 - n2;
                    case '*': return n1 * n2;
                    case '/': return n2 !== 0 ? Math.round((n1 / n2) * 100) / 100 : 0;
                }
            }

            checkAnswer() {
                const answer = parseFloat(this.userAnswer);
                if (answer === this.correctAnswer) {
                    this.feedback = 'Correct!';
                    this.currentOp = this.operators[Math.floor(Math.random() * this.operators.length)];
                    this.grid[1][3].value = this.currentOp;
                    this.currentPair = this.getRandomPair();
                    this.correctAnswer = this.calculateAnswer();
                    this.userAnswer = '';
                    answerInput.value = '';
                    this.wrongFlashTimer = 0;
                } else {
                    this.feedback = 'Wrong! Try again!';
                    this.wrongFlashTimer = 60;
                    answerInput.classList.add('shake');
                    setTimeout(() => answerInput.classList.remove('shake'), 500);
                }
                this.feedbackTimer = 120;
            }

            drawRectangle() {
                const partWidth = canvas.width / 7;
                const partHeight = canvas.height / 3;

                for (let y = 0; y < 3; y++) {
                    for (let x = 0; x < 7; x++) {
                        const cell = this.grid[y][x];
                        ctx.fillStyle = cell.color;
                        ctx.fillRect(x * partWidth, y * partHeight, partWidth, partHeight);

                        ctx.fillStyle = 'black';
                        ctx.font = cell.type === 'operator' ? '40px Arial' : '30px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(cell.value, x * partWidth + partWidth / 2, y * partHeight + partHeight / 2);

                        const isHighlighted = this.currentPair.some(pos => pos[0] === x && pos[1] === y);
                        if (isHighlighted) {
                            ctx.beginPath();
                            ctx.arc(x * partWidth + partWidth / 2, y * partHeight + partHeight / 2, 40, 0, Math.PI * 2);
                            ctx.strokeStyle = this.wrongFlashTimer > 0 && this.wrongFlashTimer % 20 < 10 ? 'red' : 'black';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                    }
                }
            }

            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                this.drawRectangle();
                if (this.feedbackTimer > 0) {
                    ctx.font = '30px Arial';
                    ctx.fillStyle = this.feedback === 'Correct!' ? 'green' : 'red';
                    ctx.fillText(this.feedback, canvas.width / 2, canvas.height + 40);
                    this.feedbackTimer--;
                    if (this.wrongFlashTimer > 0) this.wrongFlashTimer--;
                }
            }
        }

        const game = new RectangleMathGame();

        answerInput.addEventListener('input', (e) => {
            game.userAnswer = e.target.value;
        });

        answerInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                game.checkAnswer();
            }
        });

        function gameLoop() {
            game.draw();
            requestAnimationFrame(gameLoop);
        }
        gameLoop();
    </script>
</body>
</html>

